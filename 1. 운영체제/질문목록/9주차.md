# 9주차 질문 목록

## ❓ 김선형
1. page size를 감소시키면 어캐됨?
    
    → 페이지 수 증가
    
    → 페이지 테이블 크기 증가
    
    → 내부 조각 감소
    
    → disk transfer의 효율성 감소
    
    → 필요한 정보만 메모리에 올라와 메모리 이용에 효율적
    
    → locality의 활용 측면에서는 좋지 않음
    
2. FIFO의 단점? 메모리 크기 (frame의 수) 크면 클수록, page fault가 더 늘어남 ⇒ FIFO Anomaly
3. 캐슁이란? 한정된 빠른 공간(캐쉬)에 요청된 데이터를 저장해놓고, 똑같은 데이터를 요청하게 되면 저장 메모리(디스크 등)까지 가지 않고, 캐쉬에서 바로 서비스를 제공 → 빠름
4. clock algorithm의 동작 과정? reference bit이 1이라면, 쫓아내진 않고, bit를 0으로 다시 셋팅하고 다음 페이지로 circular 이동 (reference bit이 0이라면 한 바퀴를 돌 때까지 한번도 참조를 하지 않았다는 뜻 → replace)
5. thrashing이란? 프로그램에 메모리가 너무 적게 할당되서 page fault가 지나치게 자주 일어나는 상황

## ❓ 박소민


## ❓ 배미혜


## ❓ 유승아

1. 요청한 페이지가 메모리에 없는 경우를 지칭하는 용어는
2. clock algorithm에서 어떤 bit를 사용하여 교체 대상 페이지를 선정하는가?
3. 위 문제의 bit와 함께 clock algorithm을 개선하기 위해 사용하는 다른 bit는 무엇이고 용도는 무엇인가?
4. LRU와 LFU의 시간 복잡도는?
5. CPU가 요청한 페이지가 메모리에 없을 때, 메모리에 free frame이 없을 경우 일어나는 일은?

## ❓ 이남곤

1. demand paging의 방식은?
2. FIFO anomaly란?
3. LRU, LFU 알고리즘에 대한 설명
4. clock 알고리즘의 동작 방식은?
5. thrashing에 대한 설명

## ❓ 이예은


## ❓ 이채림
