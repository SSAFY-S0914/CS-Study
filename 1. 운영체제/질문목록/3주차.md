# 3주차 질문 목록

## ❓ 김선형


## ❓ 배미혜
1. 메모리가 부족할경우 프로세스를 쫓아내게 된다. 이것을 관리하는 스케줄러는?
2. 프로세스를 변환하는 과정을 —— —- 라고 한다.
3. Blocked가 되는 예시를 하나 말하시오
4. 스레드의 장점 3가지
5. 프로세스를 스케줄링하기 위한 큐의 종류 3가지

## ❓ 유승아

1. 프로세스의 상태 크게 3개
2. ready와 blocked의 차이
3. 시스템 콜이나 인터럽트 발생 시 반드시 문맥 교환이 일어나지는 않는다. 그럼 언제 일어날까?
4. 어느 것이 스레드 간 독립적으로 가지고 있는 부분이고, 어느 것이 동료 스레드와 공유하는 부분일까?  
(1) data section
(2) stack space
(3) register set
(4) code section
(5) program counter
(6) OS resource
5. 스레드의 장점 3가지

## ❓ 이남곤

1. 프로세스가 가질 수 있는 5가지 상태에 대해서 말해주세요.
2. 문맥 교환에 대해서 말해주세요.
3. 스케줄러 3가지에 대해서 말해주세요.
    1. Long-term Scheduler와 Short-term Scheduler의 차이점에 대해서 말해주세요.
4. Suspended 상태에 대해서 말해주세요.
5. 쓰레드가 가지는 3가지 구성 요소에 대해서 말해주세요.

## ❓ 이예은
1. 다음의 실행 결과를 적으시오.

왼쪽이 부모, 아랫쪽이 자식 프로세스라고 가정한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8513bec7-731b-42a2-9158-1598fe86376d/Untitled.png)

- 프로세스의 생명 주기를 시스템 콜을 예시로 들어 설명하시오
    
    fork() 로 생성, exec() 메모리에 올림. exit or abort로 종료
    

프로세스의 상태 변화를 disk에 접근하는 작업을 예시로 들어 설명하라.

- 2. 프로세스의 상태를 나타내는 blocked와 suspended 차이
    
    blocked: 자신이 요청한 event를 기다리는 상태. 만족되면 ready된다. 
    
    suspended:  완전한 정지. 디스크에서 swapper(중기 스케쥴러) 에 의해 swap out 되었다. 
    외부에서 정지시켰기 때문에(inactive상태), 외부에서 다시 재개해야한다(active 상태).
    ctrl+z 또한 suspended이다. 사람이 재개해야한다.
    
- 3. 동기 io와 비동기 io의 차이.
    
    입출력은 Os를 통해야한다. 그리고 오래 걸린다. 입출력을 요청한 프로세스가 기다려야 한다면(Blocked), 동기식 입출력이다. 
    
    입출력이 실행되는 동안 곧바로 cpu점유권을 가져 instruction을 실행한다면 비동기식 입출력이다.
    
    ## 동기 I/O(Synchronous I/O)
    
    동기 I/O는 데이터를 처리할 때, 요청한 작업이 완료될 때까지 기다리는 방식입니다. 즉, 요청한 작업이 끝나기 전까지 다른 작업을 할 수 없는 블로킹(Blocked) 방식입니다. 따라서, 동기 I/O에서는 여러 개의 작업을 처리할 때, 각 작업을 순서대로 처리해야 하므로 성능이 저하될 수 있습니다.
    
    1. io가 완료될 때까지 cpu를 점유권을 가지며 기다리기
    2. 다른 프로세스에게 점유권을 넘겨 기다리기
    
    두 가지의 방식으로 구현할 수 있다.
    
    ## 비동기 I/O(Asynchronous I/O)
    
    비동기 I/O는 데이터를 처리할 때, 요청한 작업이 완료될 때까지 기다리지 않고 다른 작업을 처리할 수 있는 방식입니다. 이 때, 작업 결과를 기다리지 않고 다른 작업을 처리할 수 있기 때문에 논블로킹(Non-Blocked) 방식이라고도 합니다. 따라서, 비동기 I/O에서는 여러 개의 작업을 동시에 처리할 수 있어 성능이 향상될 수 있습니다.
    
- 4. thread가 자신만 갖고있는것과 다른 쓰레드와 공유하는 것
    
    ## thread가 자신만 가지고 있는 것 (공유하지 않는 것)
    
    1. pc
    2. register set
    3. stack 공간
    
    ## thread가 동료 thread와 공유하는 것 = task
    
    code, data section + os resource
    
- medium term scheduler의 역할, 생긴 이유
    
    시분할 시스템의 경우, 프로세스가 시작되면(new 상태) 무조건 메모리를 주기 때문에, 메모리에 프로세스가 너무 많이 올라가 문제가 생길 수 있어 mid-term scheduler (swapper)가 몇개의 프로세스를 메모리에서 쫓아내는 역할을 한다.
    
    이 중기 스케쥴러 때문에 생긴 프로세스의 상태가 suspended이다.
    
    프로세스의 입장에선 blocked 또한 자신이 cpu가 아닌 io에서 일하는 중인 상태이다.
    
- 문맥 교환의 조건
    
    사용자 프로그램으로부터 다른 사용자 프로그램으로 넘어가는 것
    
- 프로세스를 스케쥴링하기 위한 큐의 종류
    
    프로세스들은 각 큐를 오가며 수행된다.
    
    - Job Queue
    현재 시스템 내에 있는 모든 프로세스의 집합
    - Ready Queue
    Ready 상태의 프로세스의 집합
    - Device Queues
    io device의 처리를 기다리는 프로세스의 집합
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0cbf8e50-fa01-434d-991c-77306e1ccc9b/Untitled.png)

실행 과정을 설명하시오.

- 위를 힌트로, 리눅스에서 쉘 프롬프트 실행 과정을 설명하시오
    
     프로그램 이름을 넣으라고 깜빡거릴 때 쉘에 이름을 입력하면 그 이름이 쉘 프롬프트의 자식 프로그램이 된다. 쉘 프롬프트는 wait에 의해 blocked 상태가 된다.
    

프로세스간 협력 방식이 왜 나왔는지, IPC의 종류 두 가지를 설명하시오.

꼬리 질문: thread도 IPC인가? 아니라면 그 이유는?

## ❓ 이채림
1.  Long-term Scheduler와 Medium-Term Scheduler의 차이
2. Suspended와 Blocked 상태의 차이?
3. 운영체제의 코드가 실행되고 있을 때 프로세스의 상태는 ?? 
4. Thread 간에 공유하지 않은 부분은?
5. 프로세스 1 → os → 프로세스 2로 넘어가는 것은 문맥교환이 맞지만
    프로세스 1 → os → 프로세스 1로 넘어가는 것은 문맥 교환이 아니다. 
    이때, 프로세스 1 → 프로세스2로 넘어가는 것이 더 부담이 큰 이유는?
